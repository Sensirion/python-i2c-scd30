#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# (c) Copyright 2022 Sensirion AG, Switzerland
#
#     THIS FILE IS AUTOMATICALLY GENERATED!
#
# Generator:    sensirion-driver-generator 0.9.0
# Product:      scd30
# Version:      None
#

import pytest
import time
from sensirion_i2c_driver import I2cConnection, CrcCalculator
from sensirion_shdlc_sensorbridge import (SensorBridgePort,
                                          SensorBridgeI2cProxy)
from sensirion_i2c_adapter.i2c_channel import I2cChannel
from sensirion_i2c_scd30.device import Scd30Device


@pytest.fixture
def sensor(bridge):
    # Configure SensorBridge port 1
    bridge.set_i2c_frequency(SensorBridgePort.ONE, frequency=100e3)
    bridge.set_supply_voltage(SensorBridgePort.ONE, voltage=3.3)
    bridge.switch_supply_on(SensorBridgePort.ONE)

    # Create SCD30 device
    i2c_transceiver = SensorBridgeI2cProxy(bridge, port=SensorBridgePort.ONE)
    channel = I2cChannel(I2cConnection(i2c_transceiver),
                         slave_address=0x61,
                         crc=CrcCalculator(8, 0x31, 0xff, 0x0))
    dev = Scd30Device(channel)
    time.sleep(2)  # some time is required to power up the device
    try:
        dev.stop_periodic_measurement()  # force sensor to be in defined state
    except Exception:
        pass

    time.sleep(0.1)
    yield dev
    # make sure the channel is powered off after executing tests
    bridge.switch_supply_off(SensorBridgePort.ONE)


@pytest.mark.needs_device
def test_stop_periodic_measurement1(sensor):
    sensor.stop_periodic_measurement()


@pytest.mark.needs_device
def test_set_measurement_interval1(sensor):
    sensor.set_measurement_interval(4)


@pytest.mark.needs_device
def test_get_measurement_interval1(sensor):
    interval = sensor.get_measurement_interval()
    print(f"interval: {interval}; ")


@pytest.mark.needs_device
def test_set_altitude_compensation1(sensor):
    sensor.set_altitude_compensation(440)


@pytest.mark.needs_device
def test_get_altitude_compensation1(sensor):
    altitude = sensor.get_altitude_compensation()
    print(f"altitude: {altitude}; ")


@pytest.mark.needs_device
def test_set_temperature_offset1(sensor):
    sensor.set_temperature_offset(2000)


@pytest.mark.needs_device
def test_get_temperature_offset1(sensor):
    temperature_offset = sensor.get_temperature_offset()
    print(f"temperature_offset: {temperature_offset}; ")


@pytest.mark.needs_device
def test_activate_auto_calibration1(sensor):
    sensor.activate_auto_calibration(1)


@pytest.mark.needs_device
def test_get_auto_calibration_status1(sensor):
    is_active = sensor.get_auto_calibration_status()
    print(f"is_active: {is_active}; ")


@pytest.mark.needs_device
def test_get_force_recalibration_status1(sensor):
    co2_ref_concentration = sensor.get_force_recalibration_status()
    print(f"co2_ref_concentration: {co2_ref_concentration}; ")


@pytest.mark.needs_device
def test_read_firmware_version1(sensor):
    (major, minor
     ) = sensor.read_firmware_version()
    print(f"major: {major}; " f"minor: {minor}; ")


@pytest.mark.needs_device
def test_soft_reset1(sensor):
    sensor.soft_reset()


@pytest.mark.needs_device
def test_start_periodic_measurement1(sensor):
    sensor.start_periodic_measurement(0)
    (co2_concentration, temperature, humidity
     ) = sensor.blocking_read_measurement_data()
    print(f"co2_concentration: {co2_concentration}; " f"temperature: {temperature}; " f"humidity: {humidity}; ")
    sensor.force_recalibration(500)
    sensor.await_data_ready()
    (co2_concentration, temperature, humidity
     ) = sensor.read_measurement_data()
    print(f"co2_concentration: {co2_concentration}; " f"temperature: {temperature}; " f"humidity: {humidity}; ")
    sensor.stop_periodic_measurement()

