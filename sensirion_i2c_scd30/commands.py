#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# (c) Copyright 2025 Sensirion AG, Switzerland
#
#     THIS FILE IS AUTOMATICALLY GENERATED!
#
# Generator:     sensirion-driver-generator 1.3.3
# Product:       scd30
# Model-Version: 1.0.0
#
"""
The transfer classes specify the data that is transferred between host and sensor. The generated transfer classes
are used by the driver class and not intended for direct use.
"""

from sensirion_driver_adapters.transfer import Transfer
from sensirion_driver_adapters.rx_tx_data import TxData, RxData


class StartPeriodicMeasurement(Transfer):
    """
    Starts continuous measurement of the SCD30 to measure CO₂ concentration, humidity and temperature.
    Measurement data which is not read from the sensor will be overwritten.
    The CO₂ measurement value can be compensated for ambient pressure by feeding the pressure value in mBar to the sensor.
    Setting the ambient pressure will overwrite previous settings of altitude compensation.
    Setting the argument to zero will deactivate the ambient pressure compensation (default ambient pressure = 1013.25 mBar).
    For setting a new ambient pressure when continuous measurement is running the whole command has to be written to SCD30.
    """

    CMD_ID = 0x10

    def __init__(self, ambient_pressure):
        self._ambient_pressure = ambient_pressure

    def pack(self):
        return self.tx_data.pack([self._ambient_pressure])

    tx = TxData(CMD_ID, '>HH', device_busy_delay=0.01, slave_address=None, ignore_ack=False)


class StopPeriodicMeasurement(Transfer):
    """Stops the continuous measurement of the SCD30."""

    CMD_ID = 0x104

    def pack(self):
        return self.tx_data.pack([])

    tx = TxData(CMD_ID, '>H', device_busy_delay=0.01, slave_address=None, ignore_ack=False)


class SetMeasurementInterval(Transfer):
    """
    Sets the interval used by the SCD30 sensor to measure in continuous measurement mode. Initial value is 2s. The chosen measurement
    interval is saved in non-volatile memory and thus is not reset to its initial value after power up.
    """

    CMD_ID = 0x4600

    def __init__(self, interval):
        self._interval = interval

    def pack(self):
        return self.tx_data.pack([self._interval])

    tx = TxData(CMD_ID, '>HH', device_busy_delay=0.01, slave_address=None, ignore_ack=False)


class GetMeasurementInterval(Transfer):
    """Reads out the active measurement interval."""

    CMD_ID = 0x4600

    def pack(self):
        return self.tx_data.pack([])

    tx = TxData(CMD_ID, '>H', device_busy_delay=0.01, slave_address=None, ignore_ack=False)
    rx = RxData('>H')


class GetDataReady(Transfer):
    """
    Data ready command is used to determine if a measurement can be read from the sensor’s buffer. Whenever there is a measurement
    available from the internal buffer this command returns 1 and 0 otherwise.
    As soon as the measurement has been read by SCD30 the return value changes to 0.
    """

    CMD_ID = 0x202

    def pack(self):
        return self.tx_data.pack([])

    tx = TxData(CMD_ID, '>H', device_busy_delay=0.01, slave_address=None, ignore_ack=False)
    rx = RxData('>H')


class ReadMeasurementData(Transfer):
    """Allows to read new measurement data if data is available."""

    CMD_ID = 0x300

    def pack(self):
        return self.tx_data.pack([])

    tx = TxData(CMD_ID, '>H', device_busy_delay=0.01, slave_address=None, ignore_ack=False)
    rx = RxData('>fff')


class ActivateAutoCalibration(Transfer):
    """
    Continuous automatic self-calibration (ASC) can be (de-)activated with this command. When activated for the first time a period of minimum 7 days
    is needed so that the algorithm can find its initial parameter set for ASC.
    The sensor has to be exposed to fresh air for at least 1 hour every day. Also during that period, the sensor may not be disconnected from the
    power supply. Otherwise the procedure to find calibration parameters is aborted and has to be restarted from the beginning.
    The successfully calculated parameters are stored in non-volatile memory of the SCD30 having the effect that after a restart the previously
    found parameters for ASC are still present.
    """

    CMD_ID = 0x5306

    def __init__(self, do_activate):
        self._do_activate = do_activate

    def pack(self):
        return self.tx_data.pack([self._do_activate])

    tx = TxData(CMD_ID, '>HH', device_busy_delay=0.01, slave_address=None, ignore_ack=False)


class GetAutoCalibrationStatus(Transfer):
    """Read out the status of the active self calibration."""

    CMD_ID = 0x5306

    def pack(self):
        return self.tx_data.pack([])

    tx = TxData(CMD_ID, '>H', device_busy_delay=0.01, slave_address=None, ignore_ack=False)
    rx = RxData('>H')


class ForceRecalibration(Transfer):
    """
    Forced recalibration (FRC) is used to compensate for sensor drifts when a reference value of the CO₂ concentration in close proximity to the SCD30 is available.
    For best results, the sensor has to be run in a stable environment in continuous mode at a measurement rate of 2s for at least two minutes before applying the
    FRC command and sending the reference value. Setting a reference CO₂ concentration by the method described here will always supersede corrections from the
    ASC (see command activate_auto_calibration) and vice-versa.
    The reference CO₂ concentration has to be within the range 400 ppm ≤ cref(CO₂) ≤ 2000 ppm. The FRC method imposes a permanent update of the CO₂ calibration curve
    which persists after repowering the sensor. The most recently used reference value is retained in volatile memory and can be read out with the command sequence
    given below. After repowering the sensor, the command will return the standard reference value of 400 ppm.
    """

    CMD_ID = 0x5204

    def __init__(self, co2_ref_concentration):
        self._co2_ref_concentration = co2_ref_concentration

    def pack(self):
        return self.tx_data.pack([self._co2_ref_concentration])

    tx = TxData(CMD_ID, '>HH', device_busy_delay=0.01, slave_address=None, ignore_ack=False)


class GetForceRecalibrationStatus(Transfer):
    """Read out the CO₂ reference concentration."""

    CMD_ID = 0x5204

    def pack(self):
        return self.tx_data.pack([])

    tx = TxData(CMD_ID, '>H', device_busy_delay=0.01, slave_address=None, ignore_ack=False)
    rx = RxData('>H')


class SetTemperatureOffset(Transfer):
    """
    The on-board RH/T sensor is influenced by thermal self-heating of SCD30 and other electrical components. Design-in alters the thermal properties of SCD30
    such that temperature and humidity offsets may occur when operating the sensor in end-customer devices.
    Compensation of those effects is achievable by writing the temperature offset found in continuous operation of the device into the sensor. Temperature offset
    value is saved in non-volatile memory. The last set value will be used for temperature offset compensation after repowering.
    """

    CMD_ID = 0x5403

    def __init__(self, temperature_offset):
        self._temperature_offset = temperature_offset

    def pack(self):
        return self.tx_data.pack([self._temperature_offset])

    tx = TxData(CMD_ID, '>HH', device_busy_delay=0.01, slave_address=None, ignore_ack=False)


class GetTemperatureOffset(Transfer):
    """Read out the actual temperature offset. The result can be converted to ℃ by dividing it by 100."""

    CMD_ID = 0x5403

    def pack(self):
        return self.tx_data.pack([])

    tx = TxData(CMD_ID, '>H', device_busy_delay=0.01, slave_address=None, ignore_ack=False)
    rx = RxData('>H')


class GetAltitudeCompensation(Transfer):
    """Read out the configured altitude (height in [m] over sea level)."""

    CMD_ID = 0x5102

    def pack(self):
        return self.tx_data.pack([])

    tx = TxData(CMD_ID, '>H', device_busy_delay=0.01, slave_address=None, ignore_ack=False)
    rx = RxData('>H')


class SetAltitudeCompensation(Transfer):
    """
    Measurements of CO₂ concentration based on the NDIR principle are influenced by altitude. SCD30 offers to compensate deviations due to altitude by using this command.
    Setting altitude is disregarded when an ambient pressure is given to the sensor (see command start_periodic_measurement).
    Altitude value is saved in non-volatile memory. The last set value will be used for altitude compensation after repowering.
    """

    CMD_ID = 0x5102

    def __init__(self, altitude):
        self._altitude = altitude

    def pack(self):
        return self.tx_data.pack([self._altitude])

    tx = TxData(CMD_ID, '>HH', device_busy_delay=0.01, slave_address=None, ignore_ack=False)


class ReadFirmwareVersion(Transfer):
    """Read the version of the current firmware."""

    CMD_ID = 0xd100

    def pack(self):
        return self.tx_data.pack([])

    tx = TxData(CMD_ID, '>H', device_busy_delay=0.01, slave_address=None, ignore_ack=False)
    rx = RxData('>BB')


class SoftReset(Transfer):
    """
    The SCD30 provides a soft reset mechanism that forces the sensor into the same state as after powering up without the need for removing the power-supply.
    It does so by restarting its system controller. After soft reset the sensor will reload all calibrated data.
    However, it is worth noting that the sensor reloads calibration data prior to every measurement by default. This includes previously set reference values
    from ASC or FRC as well as temperature offset values last setting. The sensor is able to receive the command at any time, regardless of its internal state.
    """

    CMD_ID = 0xd304

    def pack(self):
        return self.tx_data.pack([])

    tx = TxData(CMD_ID, '>H', device_busy_delay=2.0, slave_address=None, ignore_ack=False)
